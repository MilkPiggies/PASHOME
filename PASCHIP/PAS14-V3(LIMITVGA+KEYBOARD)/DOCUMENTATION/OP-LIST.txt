DEC | HEX  =  NAME | (DESCRIPTION)
0(0) = NULL		(NULL does nothing, no operation)
1(1) = KMSWP		(KMSWP switches the active codebase from KROM to MRAM or vice versa)
2(2) = INT		(INT is the interupt switch, when ran it takes the value from X to decide what kind of interupt)
3(3) = SIDEL		(SIDEL takes the value from X to set the DELAY for INT-DELAY)
4(4) = SBRM		(SBRM takes X and sets MBRANCH accordingly)
5(5) = SBRK		(SBRK takes X and Y and sets KBRANCH accordingly, Y is lo and X is hi)
6(6) = BR 		(BR will branch either KROM or MRAM depending on which codebase is active)
7(7) = LDA		(LDA will load a value on A, either directly(#) or from RAM($)
8(8) = LDB		(LDB will load a value on B, either directly(#) or from RAM($)
9(9) = LDX		(LDX will load a value on X, either directly(#) or from RAM($)
10(A) = LDY		(LDY will load a value on Y, either directly(#) or from RAM($)
11(B) = LDC		(LDC will load the values of A and B to C)
12(C) = LDZ		(LDY will load the values of X and Y to Z
13(D) = STA		(STA will store the value on A to the designated value in RAM(#), or from ZADDR($))
14(E) = STB		(STB will store the value on B to the designated value in RAM(#), or from ZADDR($))
15(F) = STX		(STX will store the value on X to the designated value in RAM(#), or from ZADDR($))	
16(10) = STY		(STY will store the value on Y to the designated value in RAM(#), or from ZADDR($))
17(11) = STC		(STC will store the value on C to A and B)
18(12) = STZ		(STZ will store the value on C to X and Y)
19(13) = SSP		(SSP will take the value on Y and put it on the STACK_POINTER)
20(14) = SPP		(SPP will add 1 to the STACK_POINTER)
21(15) = SMM		(SMM will subtract 1 from the STACK_POINTER)
22(16) = TXS		(TXS will transfer the value on X to the STACK_POINTER)
23(17) = TSX 		(TSX will transfer the value on STACK_POINTER to X)
24(18) = PHA		(PHA will push whatever is on A to where the STACK_POINTER points to in the RAM ZERO_PAGE)
25(19) = PLA		(PLA will pull whatever is on the location STACK_POINTER points to on RAM ZERO_PAGE to A)
26(1A) = PHP		(PHP will push the current PROSESSOR_STATUS onto whatever location STACK_POINTER points to in the RAM ZERO_PAGE)
27(1B) = PLP		(PLP will pull whatever location STACK_POINTER points to in the RAM ZERO_PAGE to PROCESSOR_STATUS)
28(1C) = LSR		(LSR is an ALGORITHMIC_OPERATION that shifts all bits on A right by one position, 0 is shifted into bit 7 and the original bit 0 is shifted into the Carry)
29(1D) = LSL		(LSL is an ALGORITHMIC_OPERATION that shifts all bits on A left by one position, 7 is shifted into bit 0 and the original bit 0 is shifted into the Carry)
30(1E) = ROR		(ROR is an ALGORITHMIC_OPERATION that shifts all bits on A left one position, The Carry is shifted into bit 7 and the original bit 0 is shifted into the Carry)
32(20) = ASR		(ASR is an ALGORITHMIC_OPERATION that shifts all bits on A right one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry)
33(21) = ASL		(ASL is an ALGORITHMIC_OPERATION that shifts all bits on A left one position. 0 is shifted into bit 0 and the original bit 7 is shifted into the Carry)
34(22) = ADD		(ADD will take A and B, add them, and store the result on A)
35(23) = ADC		(ADC will take A and B and the CARRY_FLAG, and add them, eg result+1 if CARRY_FLAG is set)
36(24) = SUB		(SUB will take A and B, subtract them, and store the result on A)
37(25) = SBC		(SBC will take A and B and the CARRY_FLAG, and add A and B, but subtract 1 if CARRY_FLAG is set)
38(26) = MUL		(MUL will take A and B, multiply them, and store the result on A)
39(27) = MLC		(MLC will take A and B and the CARRY_FLAG, and multiply A and B, but add 1 if CARRY_FLAG is set)
40(28) = DIV		(DIV will take A and B, divide them, and store the Quotient on A and Remainder on B)
41(29) = NOT		(NOT will A and run each bit though a NOT gate, and store the result on B)
42(2A) = AND		(AND will take A and B, run them through an AND gate and store the result on B)
43(2B) = NAND		(NAND will take A and B, run them through a NAND gate and store the result on B)
44(2C) = OR		(OR will take A and B, run them through an OR gate and store the result on B)
45(2D) = XOR		(XOR will take A and B, run them through an XOR gate and store the result on B)
46(2E) = NOR		(NOR will take A and B, run them through a NOR gate and store the result on B)
47(2F) = XNOR		(XNOR will take A and B, run them through an XNOR gate and store the result on B)
48(30) = NEG		(NEG will take A and invert it, storing the result on B)
49(31) = CMP		(CMP will take A and B, and check weather they are < | = | >, and store the result on a FLAG)
50(32) = CNT		(CNT will count how many bits are used on A, and store the count on B)
51(33) = SEC		(SEC will SET the CARRY FLAG)
52(34) = CLC		(CLC will CLEAR the CARRY FLAG)
53(35) = SEV		(SEV will SET the OVERFLOW FLAG)
54(36) = CLV		(CLV will CLEAR the OVERFLOW FLAG)
55(37) = SEZ		(SEZ will SET the ZERO FLAG)
56(38) = CLZ		(CLZ will CLEAR the ZERO FLAG)
57(39) = SEN		(SEN will SET the NEGATIVE FLAG)
58(3A) = CLN		(CLN will CLEAR the NEGATIVE FLAG)
59(3B) = SES		(SES will SET the SMALLER FLAG)
60(3C) = CLS		(CLS will CLEAR the SMALLER FLAG)
61(3D) = SEE		(SEE will SET the EQUAL FLAG)
62(3E) = CLE		(CLE will CLEAR the EQUAL FLAG)
63(3F) = SEB		(SEB will SET the BIGGER FLAG)
64(40) = CLB		(CLB will CLEAR the BIGGER FLAG)
65(41) = TGLDEC		(TGLDEC will toggle the DECIMAL FLAG)
66(42) = TGLINTDIS	(TGLINTDIS will toggle the INTERUPT_DISABLE FLAG
67(43) = BNN		(BNN will BRANCH if NOT NEGATIVE)
68(44) = BNG		(BNG will BRANCH if NEGATIVE)
69(45) = BNZ		(BNZ will BRANCH if NOT ZERO)
70(46) = BZE		(BZE will BRANCH if ZERO)
71(47) = BNO		(BNO will BRANCH if NOT OVERFLOWN)
72(48) = BOV		(BOV will BRANCH if OVERFLOWN)
73(49) = BNC		(BNC will BRANCH if NOT CARRYING)
74(4A) = BCA		(BCA will BRANCH if CARRYING)
75(4B) = BBE		(BBE will BRANCH if BIGGER or EQUAL)
76(4C) = BSE		(BSE will BRANCH if SMALLER or EQUAL)
77(4D) = BCC		(BCC will BRANCH if NOT BIGGER)
78(4E) = BCS		(BCS will BRANCH if BIGGER)
79(4F) = BNE		(BNE will BRANCH if NOT EQUAL)
80(50) = BEQ		(BEQ will BRANCH if EQUAL)
81(51) = BPL		(BPL will BRANCH if NOT SMALLER)
82(52) = BMI		(BMI will BRANCH if SMALLER)
83(53) = LEDD-SET	(LEDD-SET will set LEDDISPLAY according to X and Y) [NEEDS MORE DOCUMENTATION]
84(54) = TGLZADDR	(TGLZADDR will toggle so instead of reading the addr/val from KM-CODE, we read it from the address on Z)
85(55) = TAB		(TAB will TRANSFER the value on A to B)
86(56) = TAX		(TAX will TRANSFER the value on A to X)
87(57) = TAY		(TAX will TRANSFER the value on A to Y)
88(58) = TBA		(TBA will TRANSFER the value on B to A)
89(59) = TBX		(TBX will TRANSFER the value on B to X)
90(5A) = TBY		(TBY will TRANSFER the value on B to Y)
91(5B) = TXA		(TXA will TRANSFER the value on X to A)
92(5C) = TXB		(TXB will TRANSFER the value on X to B)
93(5D) = TXY		(TXY will TRANSFER the value on X to Y)
94(5E) = TYA		(TYA will TRANSFER the value on Y to A)
95(5F) = TYB		(TYB will TRANSFER the value on Y to B)
96(60) = TYX		(TYX will TRANSFER the value on Y to X)
97(61) = SESEGLOC	(SESEGLOC will set the SEGMENT location according to [ADDR]A and [LOCX]X and [LOCY]Y
98(62) = SEFGCOL	(SEFGCOL will set the Foreground color according to B)
99(63) = SEBGCOL	(SEBGCOL will set the Background color according to B)
100(64) = SECHLOC	(SECHLOC will set a character in VGA_SEGDAT according to [VAL]X and [ADDR]Y)
101(65) = SEKBLOC	(SEKBLOC will set the Keyboard Location, so the next character will be in that location, Using B)
102(66) = GETCHLOC	(GECHLOC will get the character from VGA_MEM using [ADDR]X and storing on ??)
103(67) = GETKBLOC	(GEKBLOC will get the current location of the keyboard, and store it on ??)
104(68) = TELRECV	(TELRECV will get the current Character on TELNET and store it on X)
105(69) = TELSEND	(TELSEND will take the current Character on X and put put it on TELNET)
106(6A) = WR2-MRAM	(WR2-MRAM will take the current value of A, B and C and store them on the address specified on X to MRAM)






